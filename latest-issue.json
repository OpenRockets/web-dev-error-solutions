[{"body":"\n## Description of the Error\n\nA common performance problem in MongoDB stems from creating overlapping indexes.  Overlapping indexes, where one index is a subset of another, lead to increased write times and unnecessary disk space consumption.  While MongoDB will choose the most appropriate index for a query, having redundant indexes can significantly slow down write operations as the database must update multiple indexes for every document insertion or modification. This can especially impact applications with high write loads, leading to noticeable performance degradation and potentially impacting application responsiveness.\n\n\n## Step-by-Step Code Fix\n\nLet's imagine we have a collection called `products` with the following schema:\n\n```json\n{\n  \"category\": \"Electronics\",\n  \"subcategory\": \"Laptop\",\n  \"brand\": \"Dell\",\n  \"price\": 1200\n}\n```\n\nWe've mistakenly created two indexes:\n\n```javascript\n// First index: category, subcategory\ndb.products.createIndex( { category: 1, subcategory: 1 } )\n\n// Second index: category, subcategory, brand (overlapping!)\ndb.products.createIndex( { category: 1, subcategory: 1, brand: 1 } )\n```\n\nThe second index overlaps with the first; it includes all the fields of the first and adds the `brand` field.  This is redundant. To fix this, we need to drop the less efficient index (the more comprehensive one in this case)\n\n\n```javascript\n// Drop the overlapping index\ndb.products.dropIndex( { category: 1, subcategory: 1, brand: 1 } )\n\n//Verify remaining indexes\ndb.products.getIndexes()\n```\n\nThis will leave only the `category` and `subcategory` index, which is sufficient for many queries involving these two fields. If queries requiring `brand` are frequent, we can create a compound index including brand:\n\n\n```javascript\n//if brand queries are frequent create a new efficient index\ndb.products.createIndex( { category: 1, brand:1 } )\n\n//verify indexes again.\ndb.products.getIndexes()\n```\n\n\n## Explanation\n\nOverlapping indexes create redundancy. MongoDB needs to update both indexes on every write, which consumes extra time and resources. Choosing the right indexes requires careful consideration of query patterns.  Generally, you want compound indexes that cover the fields used in the `$query` part of your find operations.  Avoid creating indexes on frequently updated fields unless absolutely necessary for query performance as these updates add overhead.\n\n\n## External References\n\n* [MongoDB Indexing Documentation](https://www.mongodb.com/docs/manual/indexes/)\n* [Understanding Index Selection in MongoDB](https://www.mongodb.com/blog/post/understanding-index-selection-in-mongodb)\n* [MongoDB Performance Tuning](https://www.mongodb.com/docs/manual/tutorial/optimize-for-performance/)\n\n\n## Copyright (c) OpenRockets Open-source Network. Free to use, copy, share, edit or publish.\n","number":1862,"title":"MongoDB: Overlapping Indexes and Performance Degradation"}]
