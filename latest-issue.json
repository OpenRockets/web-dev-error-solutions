[{"body":"\n## Description of the Error\n\nA common performance problem in MongoDB stems from the overuse or misuse of wildcard indexes, particularly with the `$regex` operator and excessive wildcard characters (`*`).  Wildcard indexes, while offering flexibility in querying, can significantly hinder query performance if not implemented carefully.  MongoDB struggles to efficiently utilize wildcard indexes, especially those starting with `.*` (matching anything), leading to collection scans instead of index lookups.  This results in slow query times and increased server load, especially as the collection grows.\n\n\n## Fixing Step-by-Step Code\n\nLet's assume we have a collection named `products` with a field `description` where we're frequently searching using `$regex` with wildcards.  Initially, we might have created an index like this:\n\n```javascript\ndb.products.createIndex( { description: \"text\" } ); //This is actually a text index, not a regular expression index\n```\n\nThis text index is suitable for full-text search but might not be optimal for all regex queries. A common mistake is to create a wildcard index like this which often is not very efficient:\n\n```javascript\ndb.products.createIndex( { description: 1 } ); //This is actually a simple index\n```\n\n\nThis is inefficient for wildcard searches.  A better approach involves creating more specific indexes tailored to common search patterns, avoiding excessive wildcards.\n\n**Improved Indexing Strategy:**\n\nInstead of a single wildcard index, let's create multiple compound indexes for specific search prefixes that frequently appear in queries:\n\n```javascript\n// Index for queries starting with \"Laptop\"\ndb.products.createIndex( { description: { $regex: /^Laptop/ } } );\n\n// Index for queries starting with \"Smart\"\ndb.products.createIndex( { description: { $regex: /^Smart/ } } );\n\n// Index for queries containing \"high-resolution\"\ndb.products.createIndex( { description: { $regex: /high-resolution/ } } );\n\n// Add this text index for more complex queries\ndb.products.createIndex( { description: \"text\" } );\n```\n\n\n**Fixing the Query:**\n\nEnsure your queries are also optimized. Avoid using `.*` at the beginning of your regex unless absolutely necessary.  For instance, instead of:\n\n```javascript\ndb.products.find({ description: /.*laptop.*/i })\n```\n\nUse more specific queries when possible:\n\n```javascript\ndb.products.find({ description: /laptop/i }) //If only interested in presence of laptop\ndb.products.find({ description: /^Laptop/i }) //If interested in laptop at the beginning\n```\n\n\n## Explanation\n\nThe problem lies in how MongoDB uses indexes.  Indexes are fundamentally B-tree structures.  Wildcard indexes, especially those starting with `.*`, are difficult to efficiently traverse.  The database might end up scanning a large portion of the collection even with the index present.  Creating multiple, more specific indexes allows MongoDB to narrow down the search space quickly, relying on index lookups rather than collection scans. This solution emphasizes creating indexes that precisely match the structure of the most common queries using regex.\n\n## External References\n\n* [MongoDB Indexing Documentation](https://www.mongodb.com/docs/manual/indexes/)\n* [MongoDB Regular Expression Indexes](https://www.mongodb.com/docs/manual/reference/operator/query/regex/)\n* [Understanding MongoDB Performance](https://www.mongodb.com/blog/post/understanding-mongodb-performance)\n\n\nCopyrights (c) OpenRockets Open-source Network. Free to use, copy, share, edit or publish.\n","number":2001,"title":"MongoDB: Overuse of Wildcard Indexes Leading to Performance Degradation"}]
