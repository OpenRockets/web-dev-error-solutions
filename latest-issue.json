[{"body":"\n## Description of the Error\n\nWhen storing large amounts of data, particularly rich text or multimedia content within Firestore documents representing posts, you might encounter an error indicating that the data exceeds Firestore's document size limit. This limit is currently 1 MB.  Exceeding this limit results in a `FAILED_PRECONDITION` error with a message indicating that the document is too large.  This is common when embedding large images, videos, or extensive text directly into the Firestore document.\n\n\n## Fixing the Error: Step-by-Step Code\n\nThis solution uses Cloud Storage for storing the large media files and only stores references to them in Firestore.\n\n**1. Project Setup (Assuming you already have a Firebase project and Firestore database):**\n\nMake sure you have the necessary Firebase libraries installed:\n\n```bash\nnpm install firebase\n```\n\n**2. Cloud Storage Configuration:**\n\nIn your Firebase project, enable Cloud Storage.  You'll need a service account key file for server-side operations.\n\n**3.  Upload to Cloud Storage:**\n\nThis function uploads a file to Cloud Storage and returns the download URL.\n\n```javascript\nconst { initializeApp } = require('firebase/app');\nconst { getStorage, ref, uploadBytesResumable, getDownloadURL } = require('firebase/storage');\n\nconst firebaseConfig = {\n  // Your Firebase config here\n};\n\nconst app = initializeApp(firebaseConfig);\nconst storage = getStorage(app);\n\nasync function uploadFileToStorage(file, filePath) {\n  const storageRef = ref(storage, filePath);\n  const uploadTask = uploadBytesResumable(storageRef, file);\n\n  return new Promise((resolve, reject) => {\n    uploadTask.on('state_changed',\n      (snapshot) => {\n        // Observe state change events such as progress, pause, and resume\n        // Get task progress, including the number of bytes uploaded and the total number of bytes to be uploaded\n        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\n        console.log('Upload is ' + progress + '% done');\n        switch (snapshot.state) {\n          case 'paused':\n            console.log('Upload is paused');\n            break;\n          case 'running':\n            console.log('Upload is running');\n            break;\n        }\n      },\n      (error) => {\n        // Handle unsuccessful uploads\n        reject(error);\n      },\n      () => {\n        // Handle successful uploads on complete\n        getDownloadURL(uploadTask.snapshot.ref).then((downloadURL) => {\n          resolve(downloadURL);\n        });\n      }\n    );\n  });\n}\n\n//Example Usage:\n//const file = await fetch('image.jpg').then(r => r.blob());\n//const url = await uploadFileToStorage(file, 'posts/post1/image.jpg');\n//console.log(\"File URL:\", url);\n\nmodule.exports = {uploadFileToStorage};\n```\n\n**4. Storing Post Data in Firestore:**\n\nNow, instead of storing the media directly, store only the Cloud Storage URLs:\n\n```javascript\nimport { db } from './firebase'; // Import your Firestore instance\nimport {uploadFileToStorage} from './cloudStorage'; //Import Cloud Storage function\n\nasync function createPost(post) {\n  //Upload the images first\n  const imageUrls = await Promise.all(post.images.map(async (image) => {\n    return await uploadFileToStorage(image, `posts/${post.id}/${image.name}`);\n  }));\n\n  const newPost = {\n    title: post.title,\n    content: post.content, //Keep text content in Firestore\n    images: imageUrls,\n    // ... other data\n    timestamp: new Date()\n  };\n\n  await db.collection('posts').doc(post.id).set(newPost);\n}\n```\n\n**5. Retrieving Post Data:**\n\nWhen retrieving posts, fetch the media from Cloud Storage using the URLs stored in Firestore:\n\n```javascript\nimport { db } from './firebase';\nasync function getPost(postId) {\n  const docSnap = await db.collection('posts').doc(postId).get();\n  if (docSnap.exists()) {\n    const post = docSnap.data();\n    return post;\n  } else {\n    return null;\n  }\n}\n\n\n//Example usage\ngetPost('somePostId').then((post) => {\n    console.log('Post:', post);\n    //Access Images using post.images\n});\n```\n\n\n\n## Explanation\n\nThis solution addresses the \"out of range\" error by offloading large media files to Cloud Storage, a more suitable service for storing binary data.  Firestore is optimized for structured data and document-level operations. By separating the media and metadata, you avoid exceeding the document size limit while maintaining a clean and efficient data structure. The URLs stored in Firestore act as pointers to the files in Cloud Storage, allowing you to easily retrieve the media when needed.\n\n\n## External References\n\n* **Firebase Firestore Documentation:** [https://firebase.google.com/docs/firestore](https://firebase.google.com/docs/firestore)\n* **Firebase Cloud Storage Documentation:** [https://firebase.google.com/docs/storage](https://firebase.google.com/docs/storage)\n* **Firebase JavaScript SDK:** [https://firebase.google.com/docs/web/setup](https://firebase.google.com/docs/web/setup)\n\n\nCopyrights (c) OpenRockets Open-source Network. Free to use, copy, share, edit or publish.\n","number":2639,"title":"Handling Firestore's \"out of range\" error when storing large posts"}]
