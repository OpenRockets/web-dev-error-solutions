[{"body":"\n## Description of the Error\n\nA common issue when working with Firebase Firestore and storing blog posts or other content-rich data is exceeding Firestore's document size limits (currently 1 MB).  Attempting to store large posts directly within a single Firestore document can lead to errors such as `FAILED_PRECONDITION: The document size exceeds the maximum allowed size`. This prevents the data from being written to the database.  This problem is often exacerbated by storing images or other large binary data directly within the document.\n\n## Step-by-Step Code Fix: Using Cloud Storage for Media and Referencing in Firestore\n\nThis solution leverages Firebase Cloud Storage to store large media files (images, videos, etc.) and then stores only references to these files within Firestore. This keeps Firestore documents small while still providing access to the media.\n\n\n**1. Set up Firebase Cloud Storage:**\n\nEnsure you have Firebase Cloud Storage configured in your project. This usually involves setting up rules in the Firebase console.  You can refer to the official documentation for detailed instructions: [Firebase Cloud Storage Documentation](https://firebase.google.com/docs/storage)\n\n\n**2.  Upload Media to Cloud Storage:**\n\nThis code snippet demonstrates uploading an image. Adapt as needed for other media types.\n\n```javascript\nimport { getStorage, ref, uploadBytesResumable, getDownloadURL } from \"firebase/storage\";\n\nasync function uploadImage(image, postID) {\n  const storage = getStorage();\n  const storageRef = ref(storage, `posts/${postID}/image.jpg`); // Customize path as needed\n\n  const uploadTask = uploadBytesResumable(storageRef, image);\n\n  uploadTask.on('state_changed', \n    (snapshot) => {\n      // Observe state change events such as progress, pause, and resume\n      // Get task progress, including the number of bytes uploaded and the total number of bytes to be uploaded\n      const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\n      console.log('Upload is ' + progress + '% done');\n      switch (snapshot.state) {\n        case 'paused':\n          console.log('Upload is paused');\n          break;\n        case 'running':\n          console.log('Upload is running');\n          break;\n      }\n    }, \n    (error) => {\n      // Handle unsuccessful uploads\n      console.error(\"Upload Error:\", error);\n    }, \n    () => {\n      // Handle successful uploads on complete\n      getDownloadURL(uploadTask.snapshot.ref).then((downloadURL) => {\n        console.log('File available at', downloadURL);\n        // Store downloadURL in Firestore (see next step)\n        return downloadURL;\n      });\n    }\n  );\n}\n\n// Example Usage:\nconst image = /* Your image file */; // Get the image file from input or other source\nconst postID = \"yourPostID\"; // Generate a unique ID for your post\nuploadImage(image, postID).then(downloadURL => {\n  //Use the downloadURL here\n  //Example: addDownloadURLToFirestore(postID, downloadURL)\n});\n```\n\n**3. Store Reference in Firestore:**\n\nAfter successfully uploading to Cloud Storage, store only the download URL in your Firestore document.\n\n```javascript\nimport { doc, setDoc, getFirestore } from \"firebase/firestore\";\n\nasync function addDownloadURLToFirestore(postID, downloadURL) {\n  const db = getFirestore();\n  const postRef = doc(db, \"posts\", postID);\n  await setDoc(postRef, {\n    title: \"My Post Title\",\n    content: \"This is the post content.\",\n    imageUrl: downloadURL,\n    // ... other post data\n  });\n}\n```\n\n**4. Retrieving Data:**\n\nWhen retrieving the post data, use the download URL to fetch the image from Cloud Storage.\n\n\n```javascript\nimport { getDoc, doc, getFirestore } from \"firebase/firestore\";\nimport { getStorage, ref, getDownloadURL } from \"firebase/storage\";\n\nasync function getPost(postID) {\n  const db = getFirestore();\n  const storage = getStorage();\n  const postRef = doc(db, \"posts\", postID);\n  const postSnap = await getDoc(postRef);\n  if (postSnap.exists()) {\n    const postData = postSnap.data();\n    if(postData.imageUrl) {\n      const imageRef = ref(storage, postData.imageUrl.split('/o/')[1].split('?')[0]); //Extract image path from url\n      const url = await getDownloadURL(imageRef);\n      postData.imageUrl = url; //update the url in the postData\n    }\n    return postData;\n  } else {\n    return null;\n  }\n}\n```\n\n## Explanation\n\nThis approach significantly improves scalability and performance. By separating media from your Firestore data, you avoid exceeding document size limits.  Furthermore, Cloud Storage is optimized for storing and serving large binary files, making the retrieval process more efficient.  The use of asynchronous operations ensures that your application remains responsive while handling potentially long upload and download processes.\n\n## External References\n\n* [Firebase Cloud Storage Documentation](https://firebase.google.com/docs/storage)\n* [Firebase Firestore Documentation](https://firebase.google.com/docs/firestore)\n* [Firebase JavaScript SDK](https://firebase.google.com/docs/web/setup)\n\n\nCopyrights (c) OpenRockets Open-source Network. Free to use, copy, share, edit or publish.\n","number":2310,"title":"Handling Firestore Data Storage Limits When Storing Large Posts"}]
