[{"body":"\n## Description of the Error\n\nThe \"invalid $expr in $group\" error in MongoDB arises when you use the `$expr` operator within a `$group` stage of an aggregation pipeline, but the expression within `$expr` is not compatible with the `$group` operation's requirement for grouping keys to be atomic.  This typically happens when your `$expr` uses operators that return non-atomic results (like arrays or documents) as grouping keys. MongoDB needs a single, simple value to group documents efficiently.\n\n## Scenario: Grouping by a Calculated Field with a Conditional\n\nLet's say we have a collection named `products` with the following structure:\n\n```json\n{\n  \"category\": \"Electronics\",\n  \"price\": 100,\n  \"discount\": 10\n},\n{\n  \"category\": \"Clothing\",\n  \"price\": 50,\n  \"discount\": 5\n},\n{\n  \"category\": \"Electronics\",\n  \"price\": 200,\n  \"discount\": 0\n}\n```\n\nWe want to group products by their discounted price and calculate the total discounted price for each group. A naive attempt might look like this:\n\n```javascript\ndb.products.aggregate([\n  {\n    $group: {\n      _id: { $expr: { $cond: { if: { $gt: [\"$discount\", 0] }, then: { $subtract: [\"$price\", \"$discount\"] }, else: \"$price\" } } },\n      totalDiscountedPrice: { $sum: { $cond: { if: { $gt: [\"$discount\", 0] }, then: { $subtract: [\"$price\", \"$discount\"] }, else: \"$price\" } } }\n    }\n  }\n]);\n```\n\nThis will throw the \"invalid $expr in $group\" error because the `$cond` operator (conditional expression) returns different data types depending on the condition, making the `_id` (grouping key) non-atomic.\n\n## Step-by-Step Fix\n\n**1. Create a calculated field using `$addFields`:**\n\nWe'll first create a new field containing the discounted price using the `$addFields` stage. This ensures a consistent data type for our grouping key.\n\n```javascript\ndb.products.aggregate([\n  {\n    $addFields: {\n      discountedPrice: { $cond: { if: { $gt: [\"$discount\", 0] }, then: { $subtract: [\"$price\", \"$discount\"] }, else: \"$price\" } }\n    }\n  },\n  // ...rest of the pipeline\n]);\n```\n\n\n**2. Group by the new calculated field:**\n\nNow, we can group by the newly created `discountedPrice` field, which is consistently a number.\n\n```javascript\ndb.products.aggregate([\n  {\n    $addFields: {\n      discountedPrice: { $cond: { if: { $gt: [\"$discount\", 0] }, then: { $subtract: [\"$price\", \"$discount\"] }, else: \"$price\" } }\n    }\n  },\n  {\n    $group: {\n      _id: \"$discountedPrice\",\n      totalDiscountedPrice: { $sum: \"$discountedPrice\" }\n    }\n  }\n]);\n```\n\nThis corrected aggregation will produce the desired result without the error.\n\n## Explanation\n\nThe key to solving the \"invalid $expr in $group\" error is to ensure that the grouping key (`_id`) is always a simple, atomic value (like a number, string, or boolean).  By pre-calculating the discounted price in a separate stage (`$addFields`), we avoid the inconsistent data type issue caused by the conditional operator within `$expr`.  Using `$addFields` ensures that the grouping key is consistent and atomic across all documents, satisfying MongoDB's requirements for the `$group` operation.\n\n## External References\n\n* [MongoDB Aggregation Framework Documentation](https://www.mongodb.com/docs/manual/aggregation/)\n* [MongoDB $expr Operator Documentation](https://www.mongodb.com/docs/manual/reference/operator/aggregation/expr/)\n* [MongoDB $group Operator Documentation](https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/)\n* [MongoDB $addFields Operator Documentation](https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/)\n\n\nCopyrights (c) OpenRockets Open-source Network. Free to use, copy, share, edit or publish.\n","number":2207,"title":"Overcoming the \"Invalid $expr in $group\" Error in MongoDB Aggregations"}]
